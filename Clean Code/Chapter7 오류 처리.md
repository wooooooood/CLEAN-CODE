# Chapter 7 오류 처리
- 흩어진 오류 코드 때문에 실제 코드가 하는 일을 파악하기 어렵다면 클린코드X
## 1 오류 코드보다 예외 사용
- 오류가 발생하면 예외를 던져라 `try/catch`

## 2 예외가 발생할 코드는 Try-Catch-Finally 문부터 작성
- 강제로 예외를 일으키는 테스트 케이스 작성 후 테스트에 통과하는 코드를 작성하는 방법을 권장
- 그러면 자연적으로 `try`블록의 트랜잭션 범위부터 구현하게 되므로 범위 내에서 트랜잭션 본질을 유지하기 쉬워진다

## 3 미확인 예외를 사용하라
- 안정적인 소프트웨어를 제작하기 위해

## 4 예외에 의미를 제공하라
- 오류 메세지에 정보를 담아 예외와 함께 전달 (실패한 연산 이름 / 실패 유형 등)

## 5 호출자를 고려해 예외 클래스를 정의
- 외부 API를 사용할 때는 감싸기가 최선
ex.
```java
//X
ACMEPort port = new ACMEPort(12);
try {
    port.open();
} catch {}

//Better
public LocalPort(int portNumber) {
    innerPort = new ACMEPort(portNumber);
}

public void open() {
    try {
        innerPort.open();
    } catch {}
}
```

## 6 정상 흐름을 정의
- 예외가 논리를 따라가기 어렵게 만드는 경우가 있다.
- `특수 사례 패턴 Special Case Pattern`: 클래스를 만들거나 객체를 조작해 특수 사례를 처리
    - 클래스/객체가 예외 상황을 캡슐화해서 처리하므로 클라이언트 코드가 예외 상황을 처리할 필요가 없어진다.

## 7 Null을 반환하지 마라
- null을 반환하는 코드는 일을 초래할 뿐 아니라 호출자에게 문제를 떠넘기는 것
- null 대신 예외를 던지거나 특수 사례 객채를 반환한다.
    - ex. null 대신 빈 리스트 반환

## 8 Null을 전달하지 마라
- 전달된 Null을 처리하는 것도 문제이며, 대다수 프로그래밍 언어는 호출자가 실수로 넘기는 null을 적절히 처리하는 방법이 없다.
- 애초에 null을 넘기지 못하도록 금지하는 정책이 합리적이다.

## 9 결론
- 클린 코드 = 가독성 + 안정성
- 오류 처리를 프로그램 논리와 분리해 독자적인 사안으로 고려하자
