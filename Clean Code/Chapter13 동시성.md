# Chapter 13 동시성
### 1 동시성이 필요한 이유
- 동시성은 `결합Coupling`을 없애는 전략
- 무엇과 언제를 분리하면 응용 프로그램 구조와 효율이 극적으로 나아진다
- 동시성은 항상 성능을 높여주는 것은 아니다. 여러 프로세서가 동시에 처리할 독립적 계산이 충분히 많은 경우 등에서 성능을 높여준다.
- 단일 스레드 시스템과 다중 스레드 시스템은 설계가 판이하게 다르다.
- 컨테이너의 동작, 동시 수정, 데드락 등의 문제를 알아야 한다.
- 동시성은 다소 부하를 유발한다.
- 간단한 문제라도 동시성은 복잡하다.
- 일반적으로 동시성 버그는 재현하기 어려워 일회성 문제로 여겨진다.
- 동시성 구현을 위해서는 근본적인 설계 전략을 재고해야 한다.

### 3 동시성 방어 원칙
**단일 책임 원칙 SRP: Single Responsibility Principle**
- 주어진 메소드/클래스/컴포넌트를 변경할 이유갸 하나여야 한다
- 동시성 코드는 다른 코드와 분리한다

**자료 범위 제한**
- 객체 하나를 공유한 후 동일한 필드를 수정하던 두 스레드가 서로 간섭하므로 예상치 못한 결과를 내놓을 수 있다.
- 이런 경우 공유 객체를 사용하는 코드 내 임계영역Critical section을 `synchronized` 키워드로 보호하라고 권장한다.
- 이런 임계영역의 수를 줄이는 기술이 중요하다

**자료 사본 사용**
- 공유 자료를 줄이려면 처음부터 공유하지 않는 방법이 제일 낫다
- ex. 객체를 복사해 읽기 전용으로 사용
- 사본으로 동기화를 피할 수 있다면 내부 잠금을 피해 절약하는 시간이 사본 생성과 garbage collection에 드는 부하를 상쇄할 가능성이 크다

**스레드는 가능한 독립적으로 구현**
- 다른 스레드와 자료를 공유하지 않는다
- 각 스레드는 클라이언트 요청 하나를 처리한다
- 모든 정보는 비공유 출처에서 가져오며 로컬 변수에 저장한다
- 자료를 독립적인 단위로 분할하라

### 4 라이브러리를 이해하라
- java5는 동시성 측면에서 이전 버전보다 나아진 방법을 제공한다
- 집합 컬렉션 사용

### 5 실행 모델을 이해하라
**기본 용어**
- `Bound resource`: 다중 스레드 환경에서 사용하는 자원으로 크기/숫자가 제한적이다 ex. db연결, 길이가 일정한 r/w 버퍼
- `Mutual Exclusion`: 한 번에 한 스레드만 공유 자료/자원을 사용할 수 있는 경우
- `Starvation`: 한 스레드나 여러 스레드가 아주 오랫동안/영원히 자원을 기다린다 ex. 항상 짧은 스레드에게 우선순위를 주는 경우
- `Deadlock`: 여러 스레드가 서로가 끝나기를 기다린다. 서로가 필요한 자원을 점유하고 있어 어느 쪽도 진행하지 못한다.
- `Livelock`: 락을 거는 단계에서 각 스레드가 서로를 방해한다. 스레드는 계속해서 진행하려 하지만 공명Resonance으로 인해 오랫동안/영원히 진행하지 못한다.

**생산자-소비자 Producer-Consumer**
- 하나 이상 생산자 스레드가 정보를 생성해 buffer/queue에 넣는다 -> 하나 이상 소비자 스레드가 대기열에서 정보를 가져와 사용한다
- 생산자 스레드는 빈 공간을 기다린다 <-> 소비자 스레드는 대기열에 정보가 채워지길 기다린다
- 생산자 스레드는 정보를 채우고 '정보가 있다' 신호를 보낸다 <-> 소비자 스레드는 정보를 읽고 '빈 공간이 있다' 신호를 보낸다
- 둘 다 진행이 가능함에도 서로에게서 신호를 기다릴 수 있다

**읽기-쓰기 Reders-Writers**
- 읽기 스레드를 위해 공유 자원을 사용한다 <-> 쓰기 스레드가 공유 자원을 가끔 갱신한다 => Throughput이 문제의 핵심
- 적당한 처리율과 기아 방지의 균형이 필요

**식사하는 철학자들 Dining Philosophers**
- 여러 프로세스가 자원을 얻으려고 경쟁한다.
- 데드락, 라이브락, 처리율 저하, 효율성 저하 등의 문제ㅏ 생길 수 있다.

### 6 동기화하는 메소드 사이에 의존성을 이해하라
- 공유 개체 하나에는 메소드 하나만 사용하라
- 공유 개체 하나에 여러 메소드가 필요한 경우에는
    - 클라이언트에서 잠금: 첫 번째 메소드를 호출하기 전에 서버를 잠그고 마지막 메소드를 호출할 때까지 잠금 유지
    - 서버에서 잠금: 서버를 잠그고 모든 메소드를 호출한 후 잠금을 해제하는 메소드를 구현, 클라이언트는 이를 호출
    - 연결Adapted 서버: 잠금을 수행하는 중간 단계로 서버 잠금과 유사하지만 원래 서버는 변경하지 않음

### 7 동기화하는 부분을 작게 만들어라
- 임계 영역은 반드시 보호하되 개수를 최대한 줄인다
- 필요 이상으로 임계영역 크기를 키우면 스레드 간에 경쟁이 늘어나고 프로그램 성능이 떨어진다

### 8 올바른 종료 코드는 구현하기 어렵다
- 종료 코드를 개발 초기에 생각하고 동작하게 구현. 이미 나온 알고리즘 참고

### 9 스레드 코드 테스트
- 충분한 테스트는 위험을 낮춘다
- 문제를 노출하는 테스트 케이스를 작성하고 프로그램 구성/시스템 구성/플랫폼/부하를 바꿔가며 자주 돌린다
- 테스트가 실패하면 원인을 추적하라

**말이 안 되는 실패는 잠정적인 스레드 문제로 취급하라**
- 시스템 실패를 일회성이라 취급하지 마라

**다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들자**
**다중 스레드를 쓰는 코드 부분을 쉽게 다양한 환경에 끼워 넣을 수 있게 스레드 코드를 구현하라**
- 한 스레드 / 여러 스레드 / 실행 중 스레드 수 변경
- 실제 환경 / 테스트 환경
- 빨리 / 천천히 / 다양한 속력
- 반복

**다중 스레드를 쓰는 코드 부분을 상황에 맞게 조정할 수 있게 작성**
- 처음부터 다양한 구성으로 프로그램 성능을 측정하는 방법 강구
- 스레드 개수 변경하기 쉽도록 코드 구현
- 프로그램이 돌아가는 도중 스레드 개수 변경하는 방법
- 프로그램 처리율과 효율에 따라 스스로 스레드 개수를 조율하는 방법

**프로세서 수보다 많은 스레드를 둘려보라**
- 시스템이 스레드를 Swapping할 때도 문제가 발생한다
- Swapping을 일으키려면 프로세서 수보다 많은 스레드를 돌린다
- Swapping이 잦을수록 임계영역을 빼먹거나/데드락을 일으키는 코드를 찾기 쉬워진다

**다른 플랫폼에서 돌려보라**
- 다중 스레드 코드는 플랫폼에 따라서 다르게 돌아간다
- 잠정적으로 코드가 돌아갈 모든 플랫폼에서 테스트를 수행
- 처음부터 그리고 자주 모든 목표 플랫폼에서 테스트

**보조 코드를 넣거나 / 강제로 실패를 일으켜보라**
- 직접 구현:
    - `Object.wait()`, `Object.sleep()`, `Object.yield()`, `Object.priority()` 등의 메소드로 코드를 다양한 순서로 실행한다
    - 스레드를 전혀 모르는 객체와 스레드를 제어하는 클래스로 프로그램을 분할하면 보조 코드를 추가할 위치 찾기가 쉬워진다
- 자동화: 
    - 무작위로 `sleep`/`yield`/`nop`(아무것도 안함)을 수행하는 `jiggle()`을 사용해 오류를 찾아낼 수 있다

### 10 결론
- 스레드 코드는 최대한 집약되고 작아야 한다
- 잠글 필요 없는 코드는 잠그지 않으며 잠긴 영역에서 다른 잠긴 영역을 호출하지 않는다
- 공유하는 개체 수와 범위를 최대한 줄인다
- 많은 플랫폼에서 많은 구성으로 반복해서 테스트한다
